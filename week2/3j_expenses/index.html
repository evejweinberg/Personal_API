<!DOCTYPE html>
<html lang="en">

<head>
	<title>three.js webgl - PointLight ShadowMap </title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<script src="http://code.jquery.com/jquery-3.1.0.min.js" integrity="sha256-cCueBR6CsyA4/9szpPfrX3s49M9vUU5BgtiJj06wt/s=" crossorigin="anonymous"></script>
	<style>
		body {
			font-family: Monospace;
			background-color: #000;
			color: #fff;
			margin: 0px;
			overflow: hidden;
		}

		#info {
			position: absolute;
			top: 10px;
			width: 100%;
			text-align: center;
			z-index: 100;
			display: block;
		}

		#info a {
			color: #f00;
			font-weight: bold;
			text-decoration: underline;
			cursor: pointer
		}
	</style>
</head>

<body>
	<div id="info">
		<!-- <a href="http://threejs.org" target="_blank">three.js</a> - PointLight ShadowMap by <a href="https://github.com/mkkellogg">mkkellogg</a> -->
	</div>

	<script src="js/third-party/threejs/three.js"></script>
	<script src="js/third-party/threejs/controls/OrbitControls.js"></script>
	<script src="js/third-party/threejs/Detector.js"></script>
	<script src="js/third-party/threejs/libs/stats.min.js"></script>
	<script>
		if (!Detector.webgl) Detector.addGetWebGLMessage();

		var camera, scene, renderer, stats;
		var pointLight, pointLight2;
		var torusKnot;
		var meshArray = []

		///parse the JSON
		var newList = []
		var foodCosts = []
		var alcCosts = []
		var categoryOptions = []
		var totalAlcCost = totalFoodCost = 0;



		//++=============ATTEMP # 1 =========================


		$.getJSON("../../data/ExpenseExport.json", function(data) {
			var dataArray = data.expenses
				// make an array that will hold an object for each food category.
			var arrayOfObjects = [];

			// use this variable to check if the category exists
			var exists = 0;
			var counterPush = 0

			// going over all the data we recieved and checking if we should add to an existing obeject or create a new one.
			// i'm not sure how data is structured, so please make sure you're doing the modifications according to your data structure.
			for (var i = 0; i < dataArray.length; i++) {
				for (var n = 0; n < dataArray.length; n++) {
					if (arrayOfObjects[n]) {
						console.log('checking myself ', arrayOfObjects[n].category)
						for (var t in dataArray) {
							if (arrayOfObjects[n].category === dataArray[t].category) {
								arrayOfObjects[n].cost = parseInt(arrayOfObjects[n].cost) + parseInt(dataArray[t].cost);
								console.log('total cost of ' + arrayOfObjects[n].category + ' is now ' + arrayOfObjects[n].cost)
								console.log('deleting', dataArray[t].category)
									//i cant seem to delete all of the matches
								delete dataArray[t]

							}
						}
						//maybe I can delete them this way?
						dataArray.reduce(function() {
							console.log('DELETING')
							return dataArray.category != arrayOfObjects[n].category
						})
						console.log(dataArray.length + 'is the length of original array')
							//this 'counterPush' was just an idea,
						counterPush++;
						exists = 1; // stating that the category exists in the array
						break; // stopping the for loop. no need to continue.
					}

					if (exists === 0 && n > counterPush) { // in case where we couldn't find the category in the array
						console.log('making new category ' + dataArray[i].category)
						var newCategory = {
							"category": dataArray[i].category,
							"cost": dataArray[i].cost,
						};
						arrayOfObjects.push(newCategory); // adding the new category object to the array
						break;
					}
				}
			}
			console.log(arrayOfObjects)
		});



		// ================ATTEMPT #2 ===========================

		// $.getJSON("../../data/ExpenseExport.json", function(data) {
		//
		// 	var dataArray = data.expenses
		//
		// 	var names = ["Mike", "Matt", "Nancy", "Adam", "Jenny", "Nancy", "Carl"];
		// 	var uniqueNames = [];
		// 	var uniqueNames2 = [];
		// 	$.each(names, function(i, el) {
		// 		if ($.inArray(el, uniqueNames) === -1) uniqueNames.push(el);
		// 	});
		//
		// 	$.each(dataArray, function(i, el) {
		// 		if ($.inArray(el, uniqueNames) === -1) uniqueNames2.push(el);
		// 	});
		//
		// 	console.log(uniqueNames, uniqueNames2)
		//
		//
		//
		//
		//
		// 	var count = 0
		// 		//do I need to start with one item in the array? I'd rather not
		// 	var arrayOfObjects = [{
		// 		"category": "nothing",
		// 		"cost": 0
		// 	}]
		//
		//
		// 	// take entire data array and go through it one by one
		// 	// while (count < dataArray.length) {
		// 	for (var i in arrayOfObjects) {
		// 		for (var n in dataArray) {
		//
		//
		//
		// 			if (arrayOfObjects[i].category === dataArray[n].category) {
		// 				console.log('adding ' + parseInt(dataArray[n].cost) + 'to cost')
		// 				arrayOfObjects[i].cost = arrayOfObjects[i].cost + parseInt(dataArray[n].cost)
		// 				delete dataArray[n]
		// 				console.log(dataArray.length + ' is the length of data array')
		// 			} else if (arrayOfObjects[i].category != dataArray[n].category) {
		// 				arrayOfObjects.push(dataArray[n])
		// 				console.log('just added ', dataArray[n], " to array")
		// 				break
		// 			}
		// 		}

		// 	}
		// 	count++
		//
		//
		// 	// }
		// 	//remove that first dunny nothing one I started with
		// 	delete arrayOfObjects[0]
		// 	console.log(arrayOfObjects)
		//
		// 	return arrayOfObjects
		// });




		//+++========ATTEMPT # 3====================================??//

		//
		// $.getJSON("../../data/ExpenseExport.json", function(data) {
		// 	//console.log(data.expenses)
		// 	for (i in data.expenses) {
		//
		// 		function subtotal(list, category) {
		// 			var categorySum = 0;
		// 			newList.forEach(function(value) {
		// 				if (value['category'] === category) {
		// 					categorySum += value['cost']
		// 				};
		// 			});
		// 			console.log(categorySum)
		// 			return categorySum;
		// 		}
		//
		//
		//
		//
		// 		// categoryOptions.forEach(function() {
		// 		// 		if (data.expenses[i].category == categoryOptions[i]) {
		// 		// 			//it matches
		// 		// 		}
		// 		// 		//
		// 		// 		//
		// 		// 	}
		// 		//
		// 		// })
		//
		// 		//first reduce the json to just these 2 key:value pairs
		// 		var newListItem = {
		// 			"category": data.expenses[i].category,
		// 			"cost": data.expenses[i].cost
		// 		}
		//
		// 		//if the strings match...
		// 		//look for the category name and push into different arrays, depending
		// 		if (newListItem.category == "Food") {
		// 			foodCosts.push(newListItem)
		// 		} else if (newListItem.category == "Alchohol") {
		// 			alcCosts.push(newListItem)
		// 		}
		// 		//there are 5 more categories, but for now, just do 'other'
		// 		else {
		// 			newList.push(newListItem)
		// 		}
		// 	}
		//
		// 	alcCosts.forEach(function(e, i) {
		// 		totalAlcCost += parseInt(alcCosts[i].cost)
		// 		return totalAlcCost
		// 	})
		//
		// 	foodCosts.forEach(function(e, i) {
		// 		totalFoodCost += parseInt(foodCosts[i].cost)
		// 		return totalFoodCost
		// 	})
		//
		//
		// 	console.log('alchohol', totalAlcCost)
		// 	console.log('food', totalFoodCost)
		// 	subtotal(newList, 'clothing')
		//
		//
		// 	subtotal(newList, 'food')
		// 	init();
		// 	animate();
		// });

		//done parsing JSON




		function init() {



			camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
			camera.position.set(0, 10, 40);

			scene = new THREE.Scene();
			scene.add(new THREE.AmbientLight(0x222233));

			// Lights

			function createLight(color) {

				var pointLight = new THREE.PointLight(color, 1, 30);
				pointLight.castShadow = true;
				pointLight.shadow.camera.near = 1;
				pointLight.shadow.camera.far = 30;
				// pointLight.shadowCameraVisible = true;
				pointLight.shadow.bias = 0.01;

				var geometry = new THREE.SphereGeometry(1, 12, 6);
				var material = new THREE.MeshBasicMaterial({
					color: color
				});
				var sphere = new THREE.Mesh(geometry, material);
				// pointLight.add(sphere);

				return pointLight

			}

			pointLight = createLight(0x00ff00);
			scene.add(pointLight);

			pointLight2 = createLight(0xff0000);
			scene.add(pointLight2);

			var geometry = new THREE.TorusKnotGeometry(14, 1, 150, 20);
			var material = new THREE.MeshPhongMaterial({
				color: 0xff0000,
				shininess: 100,
				specular: 0x222222
			});
			torusKnot = new THREE.Mesh(geometry, material);
			torusKnot.position.set(0, 5, 0);
			torusKnot.castShadow = true;
			torusKnot.receiveShadow = true;
			// scene.add(torusKnot);


			for (var i = 0; i < newList.length; i++) {
				console.log(newList[i].category)
					// console.log(newList[i].cost)
				if (newList[i].category == "Food") {
					console.log('food')
					var colorVal = 0xff0000
				} else if (newList[i].category == "Alchohol") {
					var colorVal = 0x9966FF
				} else {
					var colorVal = 0xCCCC00
				}
				var geometry = new THREE.BoxGeometry(2,
					newList[i].cost, 2);
				geometry.applyMatrix(new THREE.Matrix4().makeTranslation(0, (newList[i].cost) / 2, 0));
				var material = new THREE.MeshPhongMaterial({
					color: colorVal,
					shininess: 10,
					// specular: 0x111111,
					// side: THREE.BackSide
				})
				var mesh = new THREE.Mesh(geometry, material);
				mesh.position.x = -100 + 4 * i;
				mesh.receiveShadow = true;
				scene.add(mesh)
				meshArray.push(mesh)
			}
			// scene.add(meshArray);

			//

			renderer = new THREE.WebGLRenderer({
				antialias: true
			});
			renderer.setPixelRatio(window.devicePixelRatio);
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.shadowMap.enabled = true;
			renderer.shadowMap.type = THREE.BasicShadowMap;
			document.body.appendChild(renderer.domElement);

			controls = new THREE.OrbitControls(camera, renderer.domElement);
			controls.target.set(0, 10, 0);
			controls.update();

			stats = new Stats();
			document.body.appendChild(stats.dom);

			//

			window.addEventListener('resize', onWindowResize, false);

		}

		function onWindowResize() {

			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();

			renderer.setSize(window.innerWidth, window.innerHeight);

		}

		function animate() {

			requestAnimationFrame(animate);
			render();

		}

		function render() {

			var time = performance.now() * 0.001;

			pointLight.position.x = Math.sin(time) * 9;
			pointLight.position.y = Math.sin(time * 1.1) * 9 + 5;
			pointLight.position.z = Math.sin(time * 1.2) * 9;

			time += 10000;

			pointLight2.position.x = Math.sin(time) * 9;
			pointLight2.position.y = Math.sin(time * 1.1) * 9 + 5;
			pointLight2.position.z = Math.sin(time * 1.2) * 9;

			torusKnot.rotation.y = time * 0.1;

			renderer.render(scene, camera);

			stats.update();

		}
	</script>
</body>

</html>
